<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>genuary-2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #F0EEE9;
        }
        canvas {
            display: block;
        }
        .instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            color: #999;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="instructions">Press SPACE to restart animation</div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Rainbow colors matching Photos icon (8 colors for 8 petals)
        const RAINBOW_COLORS = [
            0xFF9500,  // 0: Orange (top)
            0xFFCC00,  // 1: Yellow
            0xA4D037,  // 2: Lime Green
            0x63DA38,  // 3: Green
            0x5AC8FA,  // 4: Teal
            0x5856D6,  // 5: Blue
            0xAF52DE,  // 6: Purple
            0xFF2D55   // 7: Pink/Magenta (the leader petal)
        ];

        const NUM_PETALS = 8;
        const PETAL_LENGTH = 3.5;
        const PETAL_WIDTH = 2.0;
        const PETAL_DEPTH = 0.12;

        // Scene setup
        let scene, camera, renderer, composer;
        let petals = [];  // All 8 petals stored here
        let leaderPetal = null;  // Reference to petal 7 (pink) which is the leader
        let petalsSpawned = 0;
        
        // Leader trail - gradient trail following the leader petal
        let leaderTrail = [];  // Array of trail segment objects
        const MAX_TRAIL_SEGMENTS = 20; // More segments for smoother gradient
        const TRAIL_SPAWN_INTERVAL = 0.015; // Spawn more frequently for smoother trail
        let lastTrailProgress = 0;
        let trailFadeSpeed = 0.02; // How fast trails fade when leader settles
        
        // Animation state
        let arcProgress = 0;
        let arcComplete = false;
        let animationComplete = false;
        
        const ARC_MAX_PROGRESS = 0.875; // 315 degrees (stops 45Â° before first petal)
        
        // Clock for delta time
        const clock = new THREE.Clock();

        // Easing functions
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        function easeInOutSine(t) {
            return -(Math.cos(Math.PI * t) - 1) / 2;
        }

        function easeOutBack(t) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        // Create petal shape using bezier curves
        function createPetalShape() {
            const shape = new THREE.Shape();
            
            const length = PETAL_LENGTH;
            const width = PETAL_WIDTH;
            
            // Start at base (center of flower)
            shape.moveTo(0, 0);
            
            // Right curve - bulbous shape
            shape.bezierCurveTo(
                width * 0.7, length * 0.15,
                width * 0.6, length * 0.5,
                width * 0.25, length * 0.85
            );
            
            // Rounded tip
            shape.bezierCurveTo(
                width * 0.1, length * 0.95,
                -width * 0.1, length * 0.95,
                -width * 0.25, length * 0.85
            );
            
            // Left curve back to base
            shape.bezierCurveTo(
                -width * 0.6, length * 0.5,
                -width * 0.7, length * 0.15,
                0, 0
            );
            
            return shape;
        }

        // Create petal geometry
        function createPetalGeometry() {
            const shape = createPetalShape();
            
            const extrudeSettings = {
                steps: 1,
                depth: PETAL_DEPTH,
                bevelEnabled: true,
                bevelThickness: 0.03,
                bevelSize: 0.03,
                bevelOffset: 0,
                bevelSegments: 2
            };
            
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            // Center geometry
            geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            geometry.boundingBox.getCenter(center);
            geometry.translate(-center.x, 0, -center.z);
            
            return geometry;
        }

        // Create glass material for a petal
        function createGlassMaterial(color) {
            return new THREE.MeshPhysicalMaterial({
                color: color,
                transmission: 0.7,
                roughness: 0.15,
                thickness: 1.0,
                ior: 1.4,
                transparent: true,
                opacity: 0.85,
                side: THREE.DoubleSide,
                envMapIntensity: 0.8,
                clearcoat: 0.2,
                clearcoatRoughness: 0.3,
                metalness: 0.0,
                depthWrite: false  // Prevents z-fighting between overlapping transparent petals
            });
        }

        // Petal class
        class Petal {
            constructor(index, colorHex, isLeader = false) {
                this.index = index;
                this.colorHex = colorHex;
                this.isLeader = isLeader;
                
                // Calculate final angle for this petal's position
                const angleStep = (Math.PI * 2) / NUM_PETALS;
                this.finalAngle = index * angleStep - Math.PI / 2; // Start from top
                
                this.scale = 0;
                this.targetScale = 1.0;
                this.alpha = 0;
                this.targetAlpha = 0.85;
                this.arcProgress = 0;
                this.isAnimating = true;
                this.hasSettled = false;
                
                // For the leader petal - current rotation during arc animation
                this.currentAngle = isLeader ? -Math.PI / 2 : this.finalAngle; // Leader starts at top
                
                // Create mesh
                const geometry = createPetalGeometry();
                this.material = createGlassMaterial(colorHex);
                this.mesh = new THREE.Mesh(geometry, this.material);
                
                // Position at center
                this.mesh.rotation.z = this.currentAngle;
                this.mesh.scale.set(0.01, 0.01, 0.01);
                this.mesh.position.set(0, 0, 0);
                
                // Set render order based on index
                this.mesh.renderOrder = isLeader ? 100 : index;
            }

            update(dt, globalArcProgress = 0) {
                if (this.isLeader && !this.hasSettled) {
                    // Leader petal rotates during the arc animation
                    const easedProgress = easeInOutSine(globalArcProgress / ARC_MAX_PROGRESS) * ARC_MAX_PROGRESS;
                    this.currentAngle = -Math.PI / 2 + easedProgress * Math.PI * 2;
                    this.mesh.rotation.z = this.currentAngle;
                    
                    // Scale up
                    this.scale = lerp(this.scale, this.targetScale, 0.12);
                    this.alpha = lerp(this.alpha, this.targetAlpha, 0.15);
                    
                    // Check if arc is complete - then settle to final position
                    if (globalArcProgress >= ARC_MAX_PROGRESS) {
                        this.hasSettled = true;
                        this.isAnimating = false;
                        this.mesh.renderOrder = this.index; // Reset render order to normal
                    }
                } else if (this.isAnimating) {
                    // Regular petals scale up after being spawned
                    this.arcProgress += dt * 0.7;
                    this.arcProgress = Math.min(this.arcProgress, 1);
                    
                    // Scale grows with bounce effect
                    let scaleProgress = easeOutBack(Math.min(this.arcProgress * 1.1, 1));
                    this.scale = this.targetScale * scaleProgress;
                    
                    // Fade in
                    this.alpha = lerp(this.alpha, this.targetAlpha, 0.12);
                    
                    if (this.arcProgress >= 0.99) {
                        this.hasSettled = true;
                        this.isAnimating = false;
                        this.scale = this.targetScale;
                    }
                } else {
                    // Subtle breathing animation for settled petals
                    const breathe = Math.sin(Date.now() * 0.0012 + this.finalAngle) * 0.015;
                    this.scale = this.targetScale + breathe;
                }
                
                // Apply scale
                this.mesh.scale.set(this.scale, this.scale, this.scale);
                
                // Update material opacity
                this.material.opacity = this.alpha;
            }
        }

        // Initialize scene
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xF0EEE9);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                45,
                window.innerWidth / window.innerHeight,
                0.1,
                100
            );
            camera.position.z = 12;
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);
            
            const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
            backLight.position.set(-5, -5, -5);
            scene.add(backLight);
            
            // Environment map for glass reflections
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            
            // Create gradient environment
            const envScene = new THREE.Scene();
            const envGeometry = new THREE.SphereGeometry(50, 32, 32);
            const envMaterial = new THREE.MeshBasicMaterial({
                side: THREE.BackSide,
                vertexColors: true
            });
            
            // Add gradient colors
            const colors = [];
            const positions = envGeometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const y = positions.getY(i);
                const t = (y + 50) / 100;
                const color = new THREE.Color();
                color.setRGB(
                    lerp(0.95, 1.0, t),
                    lerp(0.92, 0.98, t),
                    lerp(0.9, 1.0, t)
                );
                colors.push(color.r, color.g, color.b);
            }
            envGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const envMesh = new THREE.Mesh(envGeometry, envMaterial);
            envScene.add(envMesh);
            
            const envMap = pmremGenerator.fromScene(envScene).texture;
            scene.environment = envMap;
            pmremGenerator.dispose();
            
            // Post-processing with bloom
            composer = new EffectComposer(renderer);
            
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.3,   // strength
                0.4,   // radius
                0.85   // threshold
            );
            composer.addPass(bloomPass);
            
            // Start animation
            resetAnimation();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            
            // Start animation loop
            animate();
        }

        // Spawn the leader petal (petal 7 - pink)
        function spawnLeaderPetal() {
            const leaderIndex = 7; // Pink petal
            leaderPetal = new Petal(leaderIndex, RAINBOW_COLORS[leaderIndex], true);
            scene.add(leaderPetal.mesh);
            petals.push(leaderPetal);
            petalsSpawned++;
        }

        // Create a trail segment at the current leader position
        function createTrailSegment(angle, baseOpacity, segmentIndex) {
            const geometry = createPetalGeometry();
            
            // Initial opacity - visible but soft
            const initialOpacity = 0.35; // 35% opacity for visible soft trail
            
            // Soft pink color - slightly lighter/more pastel
            const trailColor = new THREE.Color(RAINBOW_COLORS[7]);
            trailColor.lerp(new THREE.Color(0xffffff), 0.2); // Mix with white for softer look
            
            const material = new THREE.MeshPhysicalMaterial({
                color: trailColor,
                transmission: 0.6, // Semi-transparent glass
                roughness: 0.5, // Diffuse/soft appearance
                thickness: 0.2,
                ior: 1.15,
                transparent: true,
                opacity: initialOpacity,
                side: THREE.DoubleSide,
                depthWrite: false,
                envMapIntensity: 0.2
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.z = angle;
            
            // Slightly larger scale for softer/blurry edge effect
            const softScale = leaderPetal.scale * 1.03;
            mesh.scale.set(softScale, softScale, softScale);
            mesh.position.set(0, 0, -0.05); // Slightly behind the main petals
            mesh.renderOrder = -10 - segmentIndex; // Render behind, older segments further back
            
            scene.add(mesh);
            
            return {
                mesh: mesh,
                material: material,
                opacity: initialOpacity,
                maxOpacity: initialOpacity,
                age: 0
            };
        }

        // Update all trail segments with smooth gradient fade
        function updateTrail(dt, shouldFade) {
            const totalSegments = leaderTrail.length;
            
            for (let i = leaderTrail.length - 1; i >= 0; i--) {
                const segment = leaderTrail[i];
                segment.age += dt;
                
                // Calculate position in trail (0 = oldest, 1 = newest)
                const positionRatio = i / Math.max(1, totalSegments - 1);
                
                if (shouldFade) {
                    // Rapid fade when leader has settled
                    segment.opacity -= dt * 2.0;
                } else {
                    // Smooth gradient: older segments fade faster
                    // Creates a natural trailing gradient effect
                    const ageFactor = 1 + (1 - positionRatio) * 2; // Older = faster fade
                    segment.opacity -= dt * 0.08 * ageFactor;
                    
                    // Also reduce scale slightly for softer trailing edge
                    const currentScale = segment.mesh.scale.x;
                    const newScale = currentScale * (1 - dt * 0.1 * (1 - positionRatio));
                    segment.mesh.scale.set(newScale, newScale, newScale);
                }
                
                // Apply smooth opacity with easing
                const smoothOpacity = Math.max(0, segment.opacity);
                segment.material.opacity = smoothOpacity * smoothOpacity; // Quadratic falloff for softer gradient
                
                // Remove segment if fully faded
                if (segment.opacity <= 0.001) {
                    scene.remove(segment.mesh);
                    segment.material.dispose();
                    segment.mesh.geometry.dispose();
                    leaderTrail.splice(i, 1);
                }
            }
        }

        // Clear all trail segments
        function clearTrail() {
            for (const segment of leaderTrail) {
                scene.remove(segment.mesh);
                segment.material.dispose();
                segment.mesh.geometry.dispose();
            }
            leaderTrail = [];
        }

        // Spawn a regular petal at the given index (0-6)
        function spawnPetal(index) {
            if (index >= 7) return; // Don't spawn index 7, that's the leader
            
            const petal = new Petal(index, RAINBOW_COLORS[index], false);
            scene.add(petal.mesh);
            petals.push(petal);
            petalsSpawned++;
        }

        // Reset animation
        function resetAnimation() {
            // Remove existing petals
            for (const petal of petals) {
                scene.remove(petal.mesh);
                petal.material.dispose();
            }
            petals = [];
            petalsSpawned = 0;
            leaderPetal = null;
            
            // Clear trail
            clearTrail();
            lastTrailProgress = 0;
            
            // Reset state
            arcProgress = 0;
            arcComplete = false;
            animationComplete = false;
            
            // Spawn the leader petal first (petal 7 - pink)
            spawnLeaderPetal();
            
            clock.start();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const dt = Math.min(clock.getDelta(), 0.1);
            
            // Update arc progress
            if (!arcComplete) {
                const arcSpeed = 0.28; // Slower for more visible animation
                arcProgress += dt * arcSpeed;
                arcProgress = Math.min(arcProgress, ARC_MAX_PROGRESS);
                
                // Spawn trail segments as the leader rotates
                if (leaderPetal && arcProgress - lastTrailProgress >= TRAIL_SPAWN_INTERVAL) {
                    // Calculate current leader angle
                    const easedProgress = easeInOutSine(arcProgress / ARC_MAX_PROGRESS) * ARC_MAX_PROGRESS;
                    const currentAngle = -Math.PI / 2 + easedProgress * Math.PI * 2;
                    
                    // Create trail segment at current position
                    const segment = createTrailSegment(currentAngle, leaderPetal.alpha, leaderTrail.length);
                    leaderTrail.push(segment);
                    
                    // Limit trail length - remove oldest segments smoothly
                    while (leaderTrail.length > MAX_TRAIL_SEGMENTS) {
                        const oldest = leaderTrail.shift();
                        scene.remove(oldest.mesh);
                        oldest.material.dispose();
                        oldest.mesh.geometry.dispose();
                    }
                    
                    lastTrailProgress = arcProgress;
                }
                
                // Spawn petals 0-6 as leader passes their positions
                // Leader starts at position 0 (top) and rotates clockwise
                // Each petal spawns when the leader reaches its angular position
                const spawnInterval = ARC_MAX_PROGRESS / 8; // Divide evenly for 7 spawns
                
                // Calculate how many petals should be spawned based on progress
                // petalsSpawned already includes the leader (1), so we need to spawn 7 more (indices 0-6)
                // Remove +1 so first petal doesn't spawn instantly - let leader rotate first
                const expectedRegularPetals = Math.min(
                    Math.floor((arcProgress + 0.01) / spawnInterval),
                    7
                );
                
                // Spawn petals 0-6 in order as leader passes
                while (petalsSpawned - 1 < expectedRegularPetals) {
                    spawnPetal(petalsSpawned - 1); // -1 because leader is already counted
                }
                
                // Check if arc is complete
                if (arcProgress >= ARC_MAX_PROGRESS) {
                    arcComplete = true;
                }
            }
            
            // Update trail segments (fade faster once arc is complete)
            updateTrail(dt, arcComplete);
            
            // Update all petals
            let allSettled = true;
            for (const petal of petals) {
                petal.update(dt, arcProgress);
                if (!petal.hasSettled) {
                    allSettled = false;
                }
            }
            
            if (petalsSpawned >= NUM_PETALS && allSettled && !animationComplete) {
                animationComplete = true;
            }
            
            // Render with post-processing
            composer.render();
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Handle key press
        function onKeyDown(event) {
            if (event.code === 'Space') {
                resetAnimation();
            }
        }

        // Start
        init();
    </script>
</body>
</html>
